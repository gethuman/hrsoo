{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","lib/hrsoo.js","hrsoo.min.js","lib/hrsoo.formatter.js","lib/hrsoo.lexer.js","lib/hrsoo.parser.js","lib/hrsoo.utils.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","hrsoo","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"parser","formatter","parse","stringify","format","./hrsoo.formatter","./hrsoo.parser",2,"getTimeString","time","hrs","Math","floor","mins","ampm","str","formatTime","timeProfile","currentTimezone","desiredTimezone","allDay","timezoneDiff","timezones","timeStr","allTimesStr","groupStartTime","hoursObj","options","type","everyDayAllTime","day","dayFormatted","timeFormatted","timezone","daysOfWeek","utils","aliases","days","outputStr","groupTime","groupStartDay","prevDayFormatted","substring","toUpperCase","isAllWeekSameTime","hrsText","hrsObj","est","cst","mst","pst","./hrsoo.utils",3,"readString","state","text","ch","len","index","prevChar","charAt","isIgnore","isLetter","toLowerCase","tokens","lookupAlias","op","isAmPm","push","value","isClosed","readTime","colonFound","charCount","parseInt","isNumber","totalTime","checkCommonHours","replace","indexOf","getTokens","hoursText","noLog","isSkip","log",4,"parseTimezone","token","splice","parseAmPm","prevToken","timeAllWeek","doOperations","opName","opFn","throughOp","startDayIdx","endDayIdx","startTime","endTime","prev","next","ranges","start","end","compressDayTimes","currentToken","hours","concat","getTimeProfile","timeRanges","timeRange","getDayTimes","timeToken","dayToken","j","dayTimes","upperBoundry","isAllDayEveryDay","isSameTime","sameTime","timeTokenStr","JSON","hasOwnProperty","isAllWeek","Object","keys","logHandler","lexer","./hrsoo.lexer",5,"whitespace","ignore","isNaN","aliasType","key","vals","lookup","console","operations","through","monday","tuesday","wednesday","thursday","friday","saturday","sunday"],"mappings":"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","file":"hrsoo.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Author: Jeff Whelpley\n * Date: 4/2/15\n *\n * Main interface for hrsoo when including it in node or the browser\n */\nvar parser = require('./hrsoo.parser');\nvar formatter = require('./hrsoo.formatter');\n\n// we are only exposing a couple functions from this module\nmodule.exports = {\n    parse:      parser.parse,\n    stringify:  formatter.stringify,\n    format:     formatter.format\n};\n",null,"/**\n * Author: Jeff Whelpley\n * Date: 4/3/15\n *\n * Format a hrsoo object into a particular output format\n */\nvar parser = require('./hrsoo.parser');\nvar utils = require('./hrsoo.utils');\nvar timezones = {\n    est: 500,\n    cst: 400,\n    mst: 300,\n    pst: 200\n};\n\n/**\n * Get the time string from military time + timezone difference\n * @param time\n */\nfunction getTimeString(time) {\n    time = time || 0;\n\n    // zero is the floor\n    if (time <= 0) { time = 0; }\n\n    // if time is 0, 1200 or 2400, return specific string\n    if (time === 0 || time === 2400) {\n        return 'midnight';\n    }\n    else if (time === 1200) {\n        return 'noon';\n    }\n\n    var hrs = Math.floor(time / 100);\n    var mins = time - (hrs * 100);\n    var ampm = (hrs > 11 && hrs < 24) ? 'pm' : 'am';\n\n    if (hrs > 12) {\n        hrs = hrs - 12;\n    }\n\n    var str = hrs;\n    if (mins) { str += ':' + mins; }\n\n    return str + ampm;\n}\n\n/**\n * Format time based on a time profile\n * @param timeProfile\n * @param currentTimezone\n * @param desiredTimezone\n */\nfunction formatTime(timeProfile, currentTimezone, desiredTimezone) {\n    currentTimezone = currentTimezone || 'est';\n    desiredTimezone = desiredTimezone || 'est';\n\n    if (!timeProfile) {\n        return 'closed';\n    }\n    else if (timeProfile.allDay) {\n        return 'all day';\n    }\n\n    var timezoneDiff = timezones[desiredTimezone] - timezones[currentTimezone];\n    var time = 0;\n    var timeStr = '';\n    var allTimesStr = '';\n    var groupStartTime = null;\n\n    while (time <= 2400) {\n\n        // get time string from time + am/pm and timezone diff\n        timeStr = getTimeString(time + timezoneDiff);\n\n        // if time selected and no group time yet, set it\n        if (timeProfile[time + ''] && !groupStartTime) {\n            groupStartTime = timeStr;\n        }\n        // else if either we are at midnight or no mor time selected and there is a group time, add it to the string\n        else if ((!timeProfile[time + ''] || time === 2400) && groupStartTime) {\n            if (allTimesStr) { allTimesStr += ', '; }\n            allTimesStr += groupStartTime + '-' + timeStr;\n            groupStartTime = null;\n        }\n\n        if ((time % 100) === 0) {\n            time += 30;\n        }\n        else {\n            time += 70;\n        }\n    }\n\n    return allTimesStr ? allTimesStr : 'closed';\n}\n\n/**\n * Convert an hours object to a formatted string\n * @param hoursObj\n * @param options\n * @returns {*}\n */\nfunction stringify(hoursObj, options) {\n    hoursObj = hoursObj || {};\n    options = options || {};\n\n    var type = options.type || 'medium';\n\n    // special case for 24-7\n    if (hoursObj.everyDayAllTime) {\n        return type === 'short' ? '24-7' : '24 hours, 7 days';\n    }\n\n    var currentTimezone = hoursObj.timezone || 'est';\n    var desiredTimezone = options.timezone || currentTimezone;\n    var daysOfWeek = utils.daysOfWeek;\n    var aliases = utils.aliases.days;\n    var outputStr = '';\n    var groupTime = null;\n    var groupStartDay = null;\n    var prevDayFormatted = null;\n    var day, dayFormatted, timeFormatted;\n\n    // go through the days of the week\n    for (var i = 0; i < 7; i++) {\n        day = daysOfWeek[i];\n\n        dayFormatted = type === 'short' ? aliases[day][0] :\n            type === 'medium' ? aliases[day][2] : day;\n        dayFormatted = dayFormatted.substring(0, 1).toUpperCase() + dayFormatted.substring(1);\n\n        timeFormatted = hoursObj[day] ?\n            formatTime(hoursObj[day], currentTimezone, desiredTimezone) : 'closed';\n\n        if (hoursObj.isAllWeekSameTime) {\n            outputStr = timeFormatted;\n            break;\n        }\n        else if (!groupTime) {\n            groupTime = timeFormatted;\n            groupStartDay = dayFormatted;\n        }\n        else if (timeFormatted !== groupTime) {\n\n            if (groupTime !== 'closed') {\n                if (outputStr) { outputStr += ', '; }\n                outputStr += groupStartDay;\n                if (prevDayFormatted !== groupStartDay) {\n                    outputStr += '-' + prevDayFormatted;\n                }\n                outputStr += ' ' + groupTime;\n            }\n\n            // now reset values with current\n            groupStartDay = dayFormatted;\n            groupTime = timeFormatted;\n        }\n\n        prevDayFormatted = dayFormatted;\n    }\n\n    // need to do last day which is not in the loop\n    if (groupTime && groupTime !== 'closed') {\n        if (outputStr) { outputStr += ', '; }\n        outputStr += groupStartDay;\n        if (prevDayFormatted !== groupStartDay) {\n            outputStr += '-' + prevDayFormatted;\n        }\n        outputStr += ' ' + groupTime;\n    }\n\n    return outputStr + ' ' + desiredTimezone.toUpperCase();\n}\n\n/**\n * Simple object that turns hrs of operation text to an object and\n * then stringifies the object with a particular format.\n *\n * @param hrsText\n * @param options\n * @returns {*}\n */\nfunction format(hrsText, options) {\n    var hrsObj = parser.parse(hrsText, options);\n    return stringify(hrsObj, options);\n}\n\n// expose functions\nmodule.exports = {\n    getTimeString: getTimeString,\n    formatTime: formatTime,\n    stringify: stringify,\n    format: format\n};","/**\n * Author: Jeff Whelpley\n * Date: 4/3/15\n *\n * Goal of this module is to take a string with hours of operation\n * and output a set of tokens that can be used by the parser\n */\nvar utils = require('./hrsoo.utils');\n\n/**\n * Read one string of letters\n * @param state\n */\nfunction readString(state) {\n\n    // do nothing if not the right params\n    if (!state || !state.text) {\n        return state;\n    }\n\n    var len = state.text.length;\n    var index = state.index || 0;\n    var str = '';\n    var ch;\n    var prevChar = index > 0 ? state.text.charAt(index - 1) : null;\n\n    // get one word (i.e. until not a letter)\n    while (index < len) {\n        ch = state.text.charAt(index);\n\n        if (!utils.isIgnore(ch)) {\n            if (!utils.isLetter(ch)) {\n                break;\n            }\n\n            str += ch;\n        }\n\n        index++;\n    }\n    state.index = index;\n\n    // if no string, then just return here\n    if (!str) {\n        return state;\n    }\n\n    str = str.toLowerCase();\n    state.tokens = state.tokens || [];\n\n    var timezone = utils.lookupAlias('timezones', str);\n    var day = utils.lookupAlias('days', str);\n    var op = utils.lookupAlias('operations', str);\n\n    if (utils.isAmPm(str, prevChar)) {\n        if (str === 'a') { str = 'am'; }\n        if (str === 'p') { str = 'pm'; }\n        state.tokens.push({ type: 'ampm', value: str });\n    }\n    else if (timezone) {\n        state.tokens.push({ type: 'timezone', value: timezone });\n    }\n    else if (op) {\n        state.tokens.push({ type: 'operation', value: op });\n    }\n    else if (day) {\n        state.tokens.push({ type: 'days', value: [day] });\n    }\n    else if (str === 'closed') {\n        state.tokens.push({ type: 'time', value: { isClosed: true }});\n    }\n    //else if (!utils.isIgnore(str)) {\n    //    utils.log('Unknown string ' + str, state);\n    //}\n\n    return state;\n}\n\n/**\n * Read digits and : to get a time\n * @param state\n */\nfunction readTime(state) {\n    var time = '0';\n    var ch, hrs, mins;\n    var colonFound = false;\n    var charCount = 0;\n\n    while (state.index < state.text.length) {\n        ch = state.text.charAt(state.index);\n\n        if (ch === ':' || (!colonFound && charCount < 3 && ch === '.')) {\n            colonFound = true;\n            hrs = parseInt(time);\n            time = '0';\n        }\n        else if (!utils.isNumber(ch)) {\n            break;\n        }\n        else {\n            time += ch;\n        }\n\n        charCount++;\n        state.index++;\n    }\n\n    if (hrs) {\n        mins = parseInt(time);\n    }\n    else {\n        hrs = parseInt(time);\n        mins = 0;\n    }\n\n    // in this situation the person forgot the colon\n    if (hrs > 12 && !colonFound && (hrs + '').length > 2) {\n        var totalTime = hrs;\n        hrs = Math.floor(totalTime / 100);\n        mins = totalTime - (hrs * 100);\n    }\n\n    state.tokens = state.tokens || [];\n    state.tokens.push({\n        type: 'time',\n        value: {\n            hrs: hrs,\n            mins: mins\n        }\n    });\n\n    return state;\n}\n\n/**\n * Hack function just to cover some edge cases that are harder to turn into grammer.\n * Eventually I should make this part of the grammer, though.\n *\n * @param state\n * @returns {*}\n */\nfunction checkCommonHours(state) {\n    state.tokens = state.tokens || [];\n    var text = state.text;\n\n    // do common replacements\n    text = text.replace(/eastern standard time/g, 'est');\n    text = text.replace(/eastern time/g, 'est');\n    text = text.replace(/pacific standard time/g, 'pst');\n    text = text.replace(/pacific time/g, 'pst');\n    text = text.replace(/mountain standard time/g, 'mst');\n    text = text.replace(/mountain time/g, 'mst');\n    text = text.replace(/central standard time/g, 'cst');\n    text = text.replace(/central time/g, 'cst');\n    text = text.replace(/midnight/g, '12am');\n    text = text.replace(/â€“/g, 'through');\n    text = text.replace(/ã¢â‚¬â€œ/g, 'through');\n    text = text.replace(/\\//g, ' ');\n    text = text.replace('7 days a week', '7 days');\n    text = text.replace('seven days a week', '7 days');\n\n    if (text.indexOf('24 hours') > -1) {\n        state.tokens.push({\n            type: 'time',\n            value: {\n                allDay: true\n            }\n        });\n\n        text = text.replace('24 hours', '');\n    }\n\n    if (text.indexOf('7 days') > -1) {\n        state.tokens.push({\n            type: 'days',\n            value: utils.daysOfWeek\n        });\n\n        text = text.replace('7 days', '');\n    }\n\n    state.text = text;\n    return state;\n}\n\n/**\n * Convert an hours string into a set of tokens\n * @param hoursText\n * @param options\n */\nfunction getTokens(hoursText, options) {\n\n    // no tokens returned if no text\n    if (!hoursText) { return []; }\n\n    // state is what we use as we lex\n    var state = {\n        text: hoursText.toLowerCase(),\n        index: 0,\n        tokens: []\n    };\n    var ch, op;\n\n    if (options && options.noLog) {\n        state.noLog = true;\n    }\n\n    // check the common phrases in the hours\n    state = checkCommonHours(state);\n\n    while (state.index < state.text.length) {\n        ch = state.text.charAt(state.index);\n\n        if (utils.isLetter(ch)) {\n            state = readString(state);\n        }\n        else if (utils.isNumber(ch)) {\n            state = readTime(state);\n        }\n        else if (utils.isSkip(ch)) {\n            state.index++;\n        }\n        else {\n            op = utils.lookupAlias('operations', ch);\n\n            if (op) {\n                state.tokens.push({\n                    type: 'operation',\n                    value: op\n                });\n            }\n            else {\n                utils.log('Unexpected character: ' + ch, state);\n            }\n\n            state.index++;\n        }\n    }\n\n    // now we should have all the tokens in the state\n    return state.tokens || [];\n}\n\n// expose functions\nmodule.exports = {\n    readString: readString,\n    readTime: readTime,\n    checkCommonHours: checkCommonHours,\n    getTokens: getTokens\n};","/**\n * Author: Jeff Whelpley\n * Date: 4/3/15\n *\n * This module is used to translate a set of tokens into\n * an standard JSON object with hours data\n */\nvar lexer = require('./hrsoo.lexer');\nvar utils = require('./hrsoo.utils');\n\n/**\n * Go through and process the timezone token(s)\n * @param state\n * @returns {*}\n */\nfunction parseTimezone(state) {\n    state = state || {};\n    state.tokens = state.tokens || [];\n\n    var i, token, timezone;\n\n    for (i = (state.tokens.length - 1); i >= 0; i--) {\n        token = state.tokens[i];\n\n        if (token.type === 'timezone') {\n            if (timezone && token.value !== timezone) {\n                utils.log('Multiple timezones found. Using ' + timezone + ' and ignoring ' + token.value, state);\n            }\n            else {\n                timezone = token.value;\n            }\n\n            // remove the timezone token now that we have processed it\n            state.tokens.splice(i, 1);\n        }\n    }\n\n    state.timezone = timezone || 'est';  // est is default\n    return state;\n}\n\n/**\n * Go through and process the ampm tokens. This is done by simply applying\n * the am or pm to the token directly preceeding.\n *\n * @param state\n * @returns {*}\n */\nfunction parseAmPm(state) {\n    state = state || {};\n    state.tokens = state.tokens || [];\n\n    var i, token, prevToken;\n\n    for (i = (state.tokens.length - 1); i > 0; i--) {  // not a mistake > 0 because ampm shouldn't be first token\n        token = state.tokens[i];\n        prevToken = state.tokens[i - 1];\n\n        if (token.type === 'ampm') {\n\n            // mistake if previous token is operation\n            if (prevToken.type === 'operation') {\n                state.tokens.splice(i - 1, 1);\n                i--;\n                if (i === 0) {\n                    break;\n                }\n                prevToken = state.tokens[i - 1];\n            }\n\n            if (prevToken.type === 'time') {\n                prevToken.ampm = token.value;\n            }\n            else {\n                utils.log('Previous token is ' + prevToken.type + ' ' +\n                            prevToken.value +  ' so ignore timezone ' + token.value, state);\n            }\n\n            // we have used the value so remove it\n            state.tokens.splice(i, 1);\n        }\n    }\n\n    return state;\n}\n\n/**\n * If just two time tokens with through, then assume all week\n * @param state\n */\nfunction timeAllWeek(state) {\n    state = state || {};\n    var tokens = state.tokens;\n\n    // if just one token with time add a through token\n    if (tokens.length === 2 && tokens[0].type === 'time' && tokens[1].type === 'time') {\n        tokens.splice(1, 0, {\n            type:   'operation',\n            value:  'through'\n        });\n    }\n\n    // now if three tokens that go time, through, time, then we assume all week\n    if (tokens.length === 3 &&\n        tokens[0].type === 'time' &&\n        tokens[1].type === 'operation' && tokens[1].value === 'through' &&\n        tokens[2].type === 'time') {\n\n        tokens.splice(0, 0, {\n            type: 'days',\n            value: utils.daysOfWeek\n        });\n    }\n\n    return state;\n}\n\n/**\n * Execute all tokens that with the given operation\n * @param state\n * @param opName\n * @param opFn\n * @returns {*}\n */\nfunction doOperations(state, opName, opFn) {\n    var i, token;\n\n    for (i = (state.tokens.length - 1); i >= 0 ; i--) {\n        token = state.tokens[i];\n\n        if (token.type === 'operation' && token.value === opName) {\n            state = opFn(state, i);\n        }\n    }\n\n    return state;\n}\n\n/**\n * This will process any \"through\" token which means that someone\n * was doing a range between two values (either days or times).\n *\n * @param state\n * @param index\n * @returns {*}\n */\nfunction throughOp(state, index) {\n\n    // if through is first or last token, we can't do anything so remove it and go on\n    if (index < 1 || index > (state.tokens.length - 2)) {\n        utils.log('Through operation without prev or next', state);\n        state.tokens.splice(index, 1);\n        return state;\n    }\n\n    // get the previous and next tokens for processing\n    var prev = state.tokens[index - 1];\n    var next = state.tokens[index + 1];\n    var i, startDayIdx, endDayIdx, startTime, endTime;\n\n    // if types don't match or not day or time, then just remove this token and ignore\n    if (prev.type !== next.type || (prev.type !== 'days' && prev.type !== 'time')) {\n        //utils.log('Through operation previous ' + prev.type + ' next ' + next.type, state);\n        state.tokens.splice(index, 1);\n        return state;\n    }\n    else if (prev.type === 'days') {\n\n        if (!prev.value.length || !next.value.length) {\n            utils.log('No days in prev or next', state);\n            state.tokens.splice(index, 1);\n            return state;\n        }\n\n        startDayIdx = utils.daysOfWeek.indexOf(prev.value[0]);\n        endDayIdx = utils.daysOfWeek.indexOf(next.value[0]);\n\n        if (startDayIdx < 0 || endDayIdx < 1) {\n            utils.log('Start or end day does not exist', state);\n            state.tokens.splice(index, 1);\n            return state;\n        }\n\n        prev.value = [];\n        for (i = startDayIdx; (i <= endDayIdx && i < utils.daysOfWeek.length); i++) {\n            prev.value.push(utils.daysOfWeek[i]);\n        }\n\n        // this can happen with sat - sun\n        if (endDayIdx < startDayIdx) {\n            for (i = 0; i <= endDayIdx; i++) {\n                prev.value.push(utils.daysOfWeek[i]);\n            }\n        }\n\n        // remove through and next index\n        state.tokens.splice(index, 2);\n    }\n    else if (prev.type === 'time') {\n        prev.value = prev.value || {};\n        next.value = next.value || {};\n\n        startTime = (prev.value.hrs || 0) * 100 + (prev.value.mins || 0);\n        endTime = (next.value.hrs || 0) * 100 + (next.value.mins || 0);\n\n        if ((next.ampm && next.ampm === 'pm') || (!next.ampm && endTime < 800) ||\n            (endTime === 1200 && next.ampm === 'am')) {\n\n            endTime += 1200;\n        }\n\n        if ((prev.ampm && prev.ampm === 'pm' && startTime < 1200) || (!prev.ampm && startTime < 500)) {\n            startTime += 1200;\n        }\n\n        // if times the same and both before 12 and second no pm, then move to pm\n        if (startTime === endTime && startTime <= 1200 && endTime <= 1200 && (!next.ampm || next.ampm !== 'pm')) {\n            endTime += 1200;\n        }\n\n        // endTime can be before startTime in situations where end time is late at night (ex. 8am - 2am)\n        if (endTime > 300 && startTime >= endTime) {\n            utils.log('Start time ' + startTime + ' must be before end time ' + endTime, state);\n        }\n\n        // replace prev token value with time range\n        prev.value = {\n            ranges: [{\n                start: startTime,\n                end: endTime\n            }]\n        };\n        delete prev.ampm;\n\n        // remove the through token and the second time token which aren't needed anymore\n        state.tokens.splice(index, 2);\n    }\n\n    // return the latest state\n    return state;\n}\n\n/**\n * Combine days with adjacent days and times with adjacent times\n * @param state\n */\nfunction compressDayTimes(state) {\n    state = state || {};\n    var tokens = state.tokens || [];\n\n    // not at least two tokens, return right away\n    if (tokens.length < 2) { return state; }\n\n    var prevToken, currentToken, i;\n\n    for (i = (tokens.length - 1); i > 0; i--) {\n        prevToken = tokens[i - 1];\n        currentToken = tokens[i];\n\n        // if hours listed at this point, log it because they should be ranges\n        if (i === 1 && prevToken.value.hours) {\n            utils.log('Token ' + (i - 1) + ' has hours in compressDayTimes', state);\n        }\n        if (currentToken.value.hours) {\n            utils.log('Token ' + i + ' has hours in compressDayTimes', state);\n        }\n\n        if (prevToken.type === 'time' && !prevToken.value.isClosed &&\n            currentToken.type === 'time' && !currentToken.value.isClosed) {\n\n            // concat the ranges\n            prevToken.value.ranges = prevToken.value.ranges || [];\n            prevToken.value.ranges = prevToken.value.ranges.concat(currentToken.value.ranges || []);\n\n            if (currentToken.value.allDay) {\n                prevToken.value.allDay = true;\n            }\n\n            tokens.splice(i, 1);\n        }\n        else if (prevToken.type === 'days' && currentToken.type === 'days') {\n            prevToken.value = prevToken.value.concat(currentToken.value);\n            tokens.splice(i, 1);\n        }\n    }\n\n    return state;\n}\n\n/**\n * Change ranges to booleans at 30 min increments\n * @param timeRanges\n * @returns {{}}\n */\nfunction getTimeProfile(timeRanges) {\n    timeRanges = timeRanges || [];\n\n    var timeProfile = {};\n    var i, timeRange, time, timeStr;\n\n    for (i = 0; i < timeRanges.length; i++) {\n        timeRange = timeRanges[i];\n        time = timeRange.start;\n\n        while (time < timeRange.end) {\n            timeStr = time + '';\n            timeProfile[timeStr] = true;\n\n            if (timeStr.substring(timeStr.length - 2) === '00') {\n                time += 30;\n            }\n            else {\n                time += 70;\n            }\n        }\n    }\n\n    return timeProfile;\n}\n\n\n/**\n * Combine all the days and times; output should be array of tokens each of\n * which contains array of days and array of timeranges. If the tokens are\n * not listed in perfect pairs at this point (i.e. days token paired with time token)\n * then there is a problem.\n *\n * @param state\n */\nfunction getDayTimes(state) {\n    var dayTimes = {};\n    var tokens = state.tokens || [];\n    var upperBoundry = tokens.length - 1;\n    var i = 0;\n    var timeToken, dayToken, timeProfile, j, day, time;\n    var isAllDayEveryDay = true;\n    var isSameTime = true;\n    var sameTime = null;\n\n    while (i < upperBoundry) {\n        timeToken = state.tokens[i];\n        dayToken = state.tokens[i + 1];\n\n        // if tokens not the right type, try to flip them\n        if (timeToken.type !== 'time' && dayToken.type !== 'days') {\n            timeToken = state.tokens[i + 1];\n            dayToken = state.tokens[i];\n        }\n\n        var timeTokenStr = JSON.stringify(timeToken);\n        if (!sameTime) {\n            sameTime = timeTokenStr;\n        }\n        else if (sameTime !== timeTokenStr) {\n            isSameTime = false;\n        }\n\n        // if still not the right type, log error, move up one, and go to next loop iteration\n        if (timeToken.type !== 'time' && dayToken.type !== 'days') {\n            utils.log('Tokens ' + i + ' and ' + (i + 1) + ' not time - days pair', state);\n            i++;\n            continue;\n        }\n\n        // get the time profile for a given set of ranges (i.e. map of 30 min key to boolean, i.e. 1430: true)\n        timeProfile = getTimeProfile(timeToken.value.ranges);\n\n        // now loop through days and apply profile to each day\n        for (j = 0; j < dayToken.value.length; j++) {\n            day = dayToken.value[j];\n            dayTimes[day] = dayTimes[day] || {};\n\n            if (timeToken.value.allDay) {\n                dayTimes[day].allDay = true;\n            }\n            else {\n                isAllDayEveryDay = false;\n                for (time in timeProfile) {\n                    if (timeProfile.hasOwnProperty(time)) {\n                        dayTimes[day][time] = true;\n                    }\n                }\n            }\n        }\n\n        // move up 2\n        i += 2;\n    }\n\n    var isAllWeek = Object.keys(dayTimes).length === 7;\n    if (isAllWeek && isAllDayEveryDay) {\n        return { everyDayAllTime: true };\n    }\n    else {\n        dayTimes.isAllWeekSameTime = isAllWeek && isSameTime;\n        dayTimes.timezone = state.timezone || 'est';\n        return dayTimes;\n    }\n}\n\n/**\n * Convert hours text to an object by first getting all tokens in string and then\n * working on tokens to the point where there are days - time pairs.\n *\n * @param hoursText\n * @param options\n * @return {} This object contains an array of days and an array of times (w startTime and endTime)\n */\nfunction parse(hoursText, options) {\n    var state = {};\n\n    if (options && options.noLog) {                         // noLog option mostly used for testing\n        state.noLog = true;\n    }\n\n    if (options && options.logHandler) {                    // noLog option mostly used for testing\n        state.logHandler = options.logHandler;\n    }\n\n    state.tokens = lexer.getTokens(hoursText, options);     // use lexer to get initial tokens from the string\n\n    state = parseTimezone(state);                           // get the timezone (only one allowed)\n    state = parseAmPm(state);                               // apply AM/PM to all hours\n    state = timeAllWeek(state);                             // use case where time by itself without days since all week\n    state = doOperations(state, 'through', throughOp);      // do ranges of times and days\n    state = compressDayTimes(state);                        // compress times and days together\n\n    return getDayTimes(state);                              // get object with combined days and times\n}\n\n// expose functions for this module\nmodule.exports = {\n    throughOp: throughOp,\n    parseTimezone: parseTimezone,\n    parseAmPm: parseAmPm,\n    timeAllWeek: timeAllWeek,\n    doOperations: doOperations,\n    compressDayTimes: compressDayTimes,\n    getTimeProfile: getTimeProfile,\n    getDayTimes: getDayTimes,\n    parse: parse\n};","/**\n * Author: Jeff Whelpley\n * Date: 4/3/15\n *\n * Common static helper functions and data that are used by the\n * lexer and parser\n */\n\nvar whitespace = [' ', '\\r', '\\t', '\\n', '\\v', '\\u00A0'];\nvar ignore = ['.', '(', ')', ',', 'and', ':', 'all', 'times', '&', '#', ';', '|'];\nvar daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\nvar aliases = {\n    operations: {\n        'through':  ['-', '~', 'to', 'thru']\n    },\n    timezones: {\n        est: ['et', 'eastern'],\n        cst: ['ct', 'central'],\n        mst: ['mt', 'mountain'],\n        pst: ['pt', 'pacific']\n    },\n    days: {\n        monday:     ['m', 'mo', 'mon', 'mom'],\n        tuesday:    ['t', 'tu', 'tue', 'tues'],\n        wednesday:  ['w', 'we', 'wed'],\n        thursday:   ['t', 'th', 'thu', 'thur', 'thurs'],\n        friday:     ['f', 'fr', 'fri'],\n        saturday:   ['s', 'sa', 'sat'],\n        sunday:     ['s', 'su', 'sun']\n    }\n};\n\n/**\n * Check if character is a letter\n * @param ch\n * @returns {boolean}\n */\nfunction isLetter(ch) {\n    return (('a' <= ch && ch <= 'z') ||\n        ('A' <= ch && ch <= 'Z')) && typeof ch === \"string\";\n}\n\n/**\n * Check if character is a number\n * @param ch\n * @returns {boolean}\n */\nfunction isNumber(ch) {\n    return '0' <= ch && ch <= '9' && typeof ch === \"string\";\n}\n\n/**\n * Check if character is one that we skip over\n * @param ch\n * @returns {boolean}\n */\nfunction isSkip(ch) {\n    return whitespace.indexOf(ch) > -1 || ignore.indexOf(ch) > -1;\n}\n\n/**\n * If the current char is an ignore char\n * @param ch\n * @returns {boolean}\n */\nfunction isIgnore(ch) {\n    return ignore.indexOf(ch) > -1;\n}\n\n/**\n * Check if string is either am or pm\n * @param str\n * @param prevChar\n * @returns {boolean}\n */\nfunction isAmPm(str, prevChar) {\n    return str === 'am' || str === 'pm' ||\n        (prevChar && !isNaN(prevChar) && (str === 'a' || str === 'p'));\n}\n\n/**\n * Given a particular alias type, see if given string is in there\n * @param aliasType\n * @param str\n * @returns {*}\n */\nfunction lookupAlias(aliasType, str) {\n    var lookup = aliases[aliasType] || {};\n    var keys = Object.keys(lookup);\n    var i, j, key, vals;\n\n    for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n\n        if (key === str) {\n            return key;\n        }\n\n        vals = lookup[key];\n        for (j = 0; j < vals.length; j++) {\n            if (vals[j] === str) {\n                return key;\n            }\n        }\n    }\n\n    return null;\n}\n\n/**\n * By default this will simply log messages to the console, but depending on input options,\n * this can also throw errors or potentially do more in the future when issues occur\n * @param str\n * @param state\n */\nfunction log(str, state) {\n    state = state || {};\n\n    if (state.logHandler) {\n        state.logHandler(str + ' || state = ' + JSON.stringify(state));\n    }\n    else if (!state.noLog) {\n        console.log(str + ' || state = ' + JSON.stringify(state));\n    }\n}\n\n// exposing properties and functions for this module\nmodule.exports = {\n    daysOfWeek: daysOfWeek,\n    aliases: aliases,\n    isLetter: isLetter,\n    isNumber: isNumber,\n    isSkip: isSkip,\n    isIgnore: isIgnore,\n    isAmPm: isAmPm,\n    lookupAlias: lookupAlias,\n    log: log\n};"],"sourceRoot":"/source/"}